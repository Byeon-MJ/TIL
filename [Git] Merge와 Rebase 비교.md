Git에서 `merge`와 `rebase`는 **브랜치의 변경사항을 통합**할 때 사용하는 두 가지 대표적인 방법입니다. 이 둘은 결과적으로 같은 내용을 작업 브랜치에 포함시키지만, **히스토리를 다루는 방식이 다릅니다.**

아래에서 `merge`와 `rebase`의 차이를 비교하면서 설명해드릴게요.

---

## `git merge` vs `git rebase` 비교 요약

| 항목 | `git merge` | `git rebase` |
| --- | --- | --- |
| 목적 | 두 브랜치의 변경사항을 병합 | 다른 브랜치의 커밋을 현재 브랜치 위에 다시 적용 |
| 히스토리 | 병합 커밋이 생겨서 **분기점**이 남음 | 커밋을 새로 작성해서 **히스토리가 깔끔**해짐 |
| 커밋 로그 | 브랜치 흐름이 명확하지만 복잡함 | 직선형 히스토리 (간결함) |
| 사용 시기 | 협업 중 변경 히스토리를 보존하고 싶을 때 | 개인 작업 후 메인 브랜치에 깔끔하게 반영하고 싶을 때 |
| 충돌 발생 시 | 병합 시점에 충돌 처리 | 커밋 하나하나 적용 중 충돌 처리 |

---

## 예제 상황

```bash
main  브랜치: A---B---C
feature 브랜치:     \---D---E
```

---

### `git merge`

```bash
git checkout feature
git merge main
```

- 결과:

```
A---B---C
     \   \
      D---E---M (병합 커밋)
```

- 특징:
    - **브랜치 이력 보존**
    - 협업 시 누가 어떤 변경을 했는지 보기 좋음
    - 커밋 그래프가 복잡해질 수 있음

---

### `git rebase`

```bash
git checkout feature
git rebase main
```

- 결과:

```
A---B---C---D'---E'
```

- 특징:
    - **히스토리 깔끔**
    - 병합 커밋이 없음 (D, E가 새로운 커밋으로 다시 작성됨)
    - 협업 중엔 `push --force`가 필요할 수 있음 (주의!)

---

## 사용법 요약

### `git merge`

```bash
# main 브랜치에 feature 브랜치 내용 병합
git checkout main
git merge feature
```

옵션:

- `-no-ff`: 병합 커밋을 항상 생성
- `-squash`: 커밋을 하나로 압축해서 병합

---

### `git rebase`

```bash
# feature 브랜치를 main 기준으로 재정렬
git checkout feature
git rebase main
```

옵션:

- `i` (interactive): 커밋 수정/삭제/합치기 등 가능
- `-onto`: 특정 커밋을 기준으로 rebase 범위 조정

---

## 주의사항

- `rebase`는 **협업 중인 공유 브랜치에서는 신중하게 사용**해야 합니다.
    - 커밋 해시가 바뀌므로 이미 푸시한 내용을 `rebase`하면 충돌이나 이슈가 생길 수 있음
    - 이런 경우엔 `merge`를 쓰는 것이 안전함

---

## 어떤 상황에서 어떤 걸 쓰면 좋을까?

| 상황 | 추천 명령 |
| --- | --- |
| 개인 브랜치 정리 | `git rebase` |
| 협업 브랜치 병합 | `git merge` |
| 깔끔한 커밋 로그를 만들고 싶을 때 | `git rebase -i` |
| 변경사항을 하나의 커밋으로 묶고 싶을 때 | `git merge --squash` |

---
